Topics

In conceptual order, not necessarily in the order in which these subjects will be covered:

Part I: Linear Structures

In this first part, you will review arrays and learn about basic linked lists (and a couple of variations of basic linked lists), exceptions, array lists, stacks and queues. Stacks and queues are specialized structures that can be built out of either arrays or linked lists, or "smart arrays", which are arrays that grow automatically on demand.

*** We will not assume any prior experience with linked lists ***

You will learn how to analyze the time and space efficiency of the stack and queue in big-O terms, and compare them across various implementations.

We will discuss the following specific topics. Each topic is listed with references to reading in the textbook:

Linked Lists
Linked Lists and Circular Linked Lists [Sec 4.5,4.6]
Doubly Linked Lists [Programming Problems P4.14, P4.16]
Exceptions [1.5]
Generic Types
ArrayList
Complexity Order/Running Time and Space
Basic Operations, Input Size, Asymptotic Growth of Functions [Sec 3.2,3.3,3.4]
Order of complexity and Big Oh, Worst case and average case analyses [Sec 3.5,3.6]
Stack
Properties, applications, and class [Sec 7.1,7.2.1, 7.3]
Implementation using array list or linked list [Sec 7.5]
Queue
Properties, applications, and class [Sec 6.1, 6.3]
Implementation of bounded queue using array list, and unbounded queue using linked list [Sec 6.5]

Part II: Search Structures

Starting with arrays and linked lists, you will learn increasingly specialized and sophisticated structures that are tailored for efficient searching. The emphasis is on understanding the connection between the design of the structure and the speed of search.

When speaking of search structures, we are concerned not only with searching, but also with adding (inserting) and removing (deleting) data from the structure. So, the speed of inserts and deletes becomes important as well.

Array and Linked List: Sequential Search
Sequential Search and Complexity Analysis [Sec 4.2]
Sorted Array: Binary Search
Binary Search and Complexity Analysis including Comparison Tree [Sec 5.2, 10.1]
Binary Search Tree (BST)
BST Properties [Sec 10.2]
Search, Insert and Delete [Sec 10.3]
Recursive Inorder Traversal of BST and Treesort [Pg. 362, Sec 10.2, 10.5.1]
Height-balanced BST: AVL Tree
AVL Tree properties [Sec 10.7.1]
AVL Search [10.7.2]
AVL Insert [10.7.3, 10.7.4]
Insertion general scenarios [10.7.7 Pg. 335 figures (a) and (b)]
Hash table
Hashing [Sec 12.1,12.2]
Collision resolution: chaining [Sec 12.3.3]
java.util.HashMap class [Sec 12.4]

Part III: Binary Tree and Applications

Traversals
Inorder, preorder and postorder traversals [ Sec 9.2]
Non-recursive traversals using stack and queue [Sec 9.7]
Huffman Coding
Coding and compression, Algorithm, Average code length and prefix property [Sec 9.5.1, 9.5.2, 9.5.3]
Heap
Heap as Priority Queue [Sec 11.1,11.2,11.3]
Implementation using array list [Sec 11.7]
Building a heap out of a pre-existing set of objects with priorities [Sec 13.3.1]

Part IV: Graphs

Types of Graphs and Representation
Directed and undirected graphs, weighted graphs [Sec 14.1]
Adjacency matrix and adjacency linked lists representations [Sec 14.2]
Graph Traversals
Depth-first traversal (DFS) [Sec 14.3]
Breadth-first traversal (BFS) [Sec 14.3]
Graph algorithms
Topological sort [Sec 14.4]
Dijkstra's Shortest Paths [Sec 14.6]

Part V: Sorting

Insertion sort [Sec 13.1, skip average analysis)]
Quicksort [Sec 13.2.1]
Mergesort [Sec 13.2.2]
Heap sort [Sec 13.3]
Radix sort [Sec 13.4]

